package com.bigdata.designpattern.proxy;

/**
 * 代理设计模式
 * 含义：执行被代理对象目标方法的前后，希望执行一些额外操作，实现自处理扩展目标。
 *
 * 1.静态代理：代理类聚合被代理类（持有其引用），从而实现代理类代替被代理类完成目标方法调用，本质上底层还是调用被代理类对象的目标方法，只不过在调用前后附带其他操作；（代理类爆炸）
 *      代理类与被代理类是聚合关系
 *
 * 2.动态代理
 *  2.1 JDK动态代理: 与静态代理原理相同，区别在于代理类聚合的是被代理对象的接口或父类，代理类与被代理类是兄弟关系 （继承 + 聚合），生成代理类是有JDK底层asm类库自动完成；（被代理类要有实现接口）
 *      Proxy.newProxyInstance(被代理类的类加载器、被代理类的父类集合，封装了代理编织代码InvocationHandler实例)
 *  2.2 CGLib动态代理：需要添加cglib类库，与JDK动态代理不同点在于，代理类继承了被代理类（继承），代理类完全照搬了被代理类；（要求被代理类不能是final类）
 *      new Enhancer() -> setSuperClass(被代理类) -> setCallback(封装了代理编织代码的MethodInterceptor实例) -> create() or create(Class[],Object[]) 直接创建于被代理类十分相似的代理类对象，不在持有被代理对象 -> 调用
 *
 *  反射：在不看源码情况下，直接通过类加载器了解类的方法和属性等信息的手段；
 *  asm: 可以直接通过编辑二进制字节码，实现对类的编辑。动态代理中代理类被自动生成，就是基于asm实现，它是Java具备动态语言特性的基础，比asm更疯狂的是instrument类库，可以直接在类被装载到类加载器前，修改类；
 *
 *
 * 3.AOP 面向切面编程
 *      切面Aspect包含:
 *          切入点Pointcut: 插入拓展操作的时机；
 *          通知方法Advice: 具体的拓展操作；
 *          编织过程Weave:  目标方法与拓展操作拼接过程
 *
 *      Spring框架两大核心：
 *          IOC 灵活装配对象
 *          AOP 动态拼接代码
 *
 */