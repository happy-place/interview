Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# DesignPattern

## 1\.Singleton 单例模式\(Manager、Factory\)
> align=`right`

- NOTE
<pre>单例模式：保证JVM全局始终只有一个类的实例，适合Manager、Factory 类型。</pre>

### 饿汉 \(私有化构造器\+静态方法获取唯一静态实例\)

### 懒汉（volatile 引用变量 \+ 双重检查DCL）

### 静态内部类（静态内部类中获取外部类唯一实例）

### 枚举类实例（避免反射调用私有化构造器）

## 2\.ChainOfResponsibility 责任链模式\(Filter\)
- NOTE
<pre>责任链模式
1.对同一事件进行链式调用，调用过程分为前置、后置两部分；
2.中间任意一环中断，直接开始返回；
3.以FilterChain为例，前置处理对象为Resquest，后置处理对象为Response</pre>

### Filter \(doFilter中传入Request、Response、Chain对象，实现栈式调用\)

### FilterChain \(addFilter添加多个Filter\)

## 3\.Observer 观察者模式\(Callbacl、Listener、Observer、Hook\)
- NOTE
<pre>观察者模式：
1.拥有 被观察者(事件源)、观察者(事件监听器)、观察目标(事件)3种角色；
2.被观察者可以发出多种事件，并拥有处理不同时间的监听者，监听者收到被观察者发出的事件时，做出响应的响应；
3.观察者可以同时监听多个被观察者；
4.观察目标，自身具备getSource方法，方便观察者收到事件时，回溯到事件发起者，并做出关联反应。

类比：
1.观察者模式与责任链模式非常类似，适合针对某个事件执行流水线式处理；
2.不同在于责任链模式有前置和后置处理方法，并且中间任意一环崩溃，都可终止任务传递，观察者只有前置处理，且无法终止处理流程。
</pre>

### 观察者\(event listener 同时监控多个被观察者\)

### 被观察者\(event emitor 同时拥有多个观察者\)

### 被观察目标\(event 可溯源\)
