Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# DesignPattern

## 创建型

### 1\.Singleton 单例模式\(Manager、Factory\)
> align=`right`,collapsed=`true`

- NOTE
<pre>单例模式：保证JVM全局始终只有一个类的实例，适合Manager、Factory 类型。</pre>

#### 饿汉 \(私有化构造器\+静态方法获取唯一静态实例\)

#### 懒汉（volatile 实例 \+ 双重检查DCL）

#### 静态内部类（静态内部类中获取外部类唯一实例）

#### 枚举类实例（避免反射调用私有化构造器）

### 13\.Builder 建造者设计模式 （分步构建复杂对象，避免传入多个参数）
> collapsed=`true`

- NOTE
<pre> * 建造者设计模式
 * 1.构造复杂对象时，对象的创建往往分成多个步骤，而且有些步骤不是必须的；
 * 2.复杂对象有多个部件组成，创建时需要穿很多参数，这是就可以分步骤逐个创建部件，
 边创建边装配，走完全部流程，自然得到一个完整对象，同时也避免一次性传参眼花；</pre>

#### 场景1：参数太多，眼花

#### 场景2：部件众多，有必须，有非必须

### 5\.Factory 工厂设计模式 \(SimpleFactory、AbstractFactory\)
> collapsed=`true`

- NOTE
<pre> * 工厂设计模式
 * 1.凡是通过调用方法获取对象的方式，包括构造器，静态方法在内都属于工厂设计模式；
 * 2.工厂设计模式常用在对象创建过程比较复杂的场景，如获取jdbc连接池，事务等，此外在对象生产前后，还可以执行前置或后置处理操作，如：日志、鉴权、修饰等；
 *
 * 分类：
 * 简单工厂：
 *      1.将特定需求抽象为借口，新增产品，只需新增实现即可；
 *      2.使用到的地方，通过接口引用；
 *      3.适合拓展某一类产品；
 * 抽象工厂：
 *      1.若干特定需求抽象为各自的接口或抽象类，向对应用于各自的不同实现类；
 *      2.获取不需求的操作封装在一个抽象工厂，针对不同场景，创建各自的场景工厂实现类；
 *      3.适合拓展一簇需求产品；
 *</pre>

#### SimpleFactory \(需求抽象为接口，增加新的实现，即可拓展产品\)

#### AbstractFactory \(不同需求各自抽象为接口，抽象工厂涵盖全部需求创建过程，针对不同场景实现抽象工厂，即可拓展产品簇\)

### 17\.Prototype 原型设计模式（拷贝已有对象，然后微调，快速获取新对象）
> collapsed=`true`

- NOTE
<pre> * 原型设计模式
 * 1.创建对象，不一定需要new，如果需要创建对象与已经存在对象差异非常小，可以直接拷贝已经存在对象，作为新对象，然后修改部分属性，即可完成新对象创建；
 * 2.需要实现Cloneable接口（标记接口，没有任何方法），重写clone()方法，只重写方法，不实现接口，编译通过，运行时报错；
 * 3.clone方法调用本地native方法，具体使用时，需要区分深克隆、还是浅克隆；
 *
 * 浅克隆：基本类型属性直接拷贝，引用类型拷贝引用关系，底层指向的是同一个对象，会导致一改全改；
 * 深克隆：引用类型自身也必须实现Cloneable接口，且在其属主的clone()方法内部，对引用类型属性本身也执行clone()，从而获得全新对象，而不是指向老对象的引用；</pre>

#### 浅拷贝 \(基本类型直接拷贝内容，引用类型拷贝引用\)

#### 深拷贝 \(引用类型也拷贝对象\)

### 23\.Factory Method 工厂方法设计模式
> collapsed=`true`

- NOTE
<pre> * 工厂方法设计模式
 * 1.产品和工厂都是抽象的；
 * 2.产品有众多具体实现；
 * 3.工厂对应衍生出跟产品一对一关系的具体实现；
 * 4.获取产品时，通过工厂获取</pre>

#### Product
> collapsed=`true`


##### ProductA

##### ProductB

#### Factory
> collapsed=`true`


##### ProductAFactory

##### ProductBFactory

## 结构型

### 14\.Adapter 适配器设计模式 （沟通两个互不兼容对象时常用）
> collapsed=`true`

- NOTE
<pre> * 适配器设计模式
 * 沟通两个不能直接通信的组件时使用，
 * 如：java 字节流转字符流 InputStreamReader、字符流转字节流 OutStreamWriter，
 * jdbc-odbc-bridge.jar jdbc访问微软SQL-Server数据库需要用到驱动转换器。
 * 
 * 注：awt包中 WindowAdapter、KeyAdapter 都不是真正的Adapter设计模式，而是在原因WindowListener基础上，
 * 添加空实现层WindowAdapter，方便使用时， 只针对特定方法进行拓展，避免重写太多抽象方法；</pre>

#### 场景1：字节流字符流，通常借助InputStreamReader、OutputStreamWriter进行转换

#### 场景2：jdbc协议访问odbc协议数据源，借助jdbc\-odbc\-bridge\.jar驱动转换

### 15\.Bridge 桥接设计模式 （抽象和具体两个维度同时拓展，然后抽象聚合具体，实现丰富组合关系）
> collapsed=`true`

- NOTE
<pre> * 桥接模式
 * 1.分离具体和抽象，抽象与具体双维度拓展；
 * 2.聚合取代继承，连接具体和抽象；
 *
 * 示例：
 * 礼物
 * 按风格划分有：温暖型、冷酷型、清新型 等抽象范畴；
 * 按具体品类有：书籍、电子产品、运动装备 等抽象范畴；
 * 不同品类又有不同具体实现，而且可能会属于不同风格；
 *
 * 走多继承体现，可能导致类爆炸;
 * 因此将礼物抽象为风格和品类两个维度，各自拓展，需要用到时，风格中维度持有品类维度引用（聚合关系），即可实现丰富组合关系；</pre>

#### Gift \(thing\)
> collapsed=`true`


##### WarmGift

##### CoolGift

#### Thing
> collapsed=`true`


##### Book

##### Car

### 8\.Composite 组合设计模式 \(专门处理树状结构数据，递归遍历\)
> collapsed=`true`

- NOTE
<pre> * 组合设计模式
 * 1.专门用于处理树状结构；
 * 2.通常需要递归遍历全部节点</pre>

#### Node
> collapsed=`true`


##### Leaf

##### Branch \(addNode\)

### 7\.Decorator 装饰器设计模式 （与APO类似实现自处理方式）
> collapsed=`true`

- NOTE
<pre> * 装饰器设计模式
 * 1.属于自处理设计模式；
 * 2.目标是在被装饰者执行特定操作前后，添加其余相关操作，原来调用被装饰者位置，改为调用装饰者，在目标方法被调用同时，自处理代码也执行了
 * 3.装饰通常按场景划分，而且适用于系统中多种类型对象，因此往往可以在需要被装饰的类基础上，抽象公共父类，然后装饰者中持有的被装饰对象引用，
 * 从具体类，变成抽象父类，实现装饰逻辑复用；
 * 3.此外多场景重叠时，可以让装饰器也实现被装饰类的父类，外层装饰器持有内层装饰器引用，从而实现装饰逻辑的嵌套调用</pre>

#### 方式1：装饰器直接持有被装饰对象引用

#### 方式2：装饰器持有被装饰对象公共父类的引用，方便装饰逻辑复用

#### 方式3：在2基础上，装饰器自身基础被装饰对象父类，从而实现装饰逻辑嵌套

### 22\.Facade 门面设计模式（参考Decoator调停者设计模式）
> collapsed=`true`

- NOTE
<pre>门面设计模式

封装系统模块与外部交互的逻辑，与调停者设计模式类似。
调停者封装的系统内部之间调用关系，门面封装的是系统与外部客户端交互关系。</pre>

#### client

#### facade

#### server

### 9\.Flyweight 享元设计模式 \(线程池、连接池、String，强调复用\)
> collapsed=`true`

- NOTE
<pre> * 享元设计模式
 * 1.共享元数据含义；
 * 2.系统中创建对象维护在池子里面，外界多出引用指向的很可能是池子中相同对象；
 * 3.常见于线程池、连接池，常量池</pre>

#### FlyweightPool \(isAlived\)
> collapsed=`true`


##### Flyweight

#### Client \(getFlyweight\)

### 10\.Proxy 代理设计模式 \(静态代理、动态代理、AOP\)
> collapsed=`true`

- NOTE
<pre> * 代理设计模式
 * 含义：执行被代理对象目标方法的前后，希望执行一些额外操作，实现自处理扩展目标。
 * 
 * 1.静态代理：代理类聚合被代理类（持有其引用），从而实现代理类代替被代理类完成目标方法调用，本质上底层还是调用被代理类对象的目标方法，只不过在调用前后附带其他操作；（代理类爆炸）
 *      代理类与被代理类是聚合关系
 *      
 * 2.动态代理
 *  2.1 JDK动态代理: 与静态代理原理相同，区别在于代理类聚合的是被代理对象的接口或父类，代理类与被代理类是兄弟关系 （继承 + 聚合），生成代理类是有JDK底层asm类库自动完成；（被代理类要有实现接口）
 *      Proxy.newProxyInstance(被代理类的类加载器、被代理类的父类集合，封装了代理编织代码InvocationHandler实例)
 *  2.2 CGLib动态代理：需要添加cglib类库，与JDK动态代理不同点在于，代理类继承了被代理类（继承），代理类完全照搬了被代理类；（要求被代理类不能是final类）
 *      new Enhancer() -&gt; setSuperClass(被代理类) -&gt; setCallback(封装了代理编织代码的MethodInterceptor实例) -&gt; create() or create(Class[],Object[]) 直接创建于被代理类十分相似的代理类对象，不在持有被代理对象 -&gt; 调用
 *  
 *  反射：在不看源码情况下，直接通过类加载器了解类的方法和属性等信息的手段；
 *  asm: 可以直接通过编辑二进制字节码，实现对类的编辑。动态代理中代理类被自动生成，就是基于asm实现，它是Java具备动态语言特性的基础，比asm更疯狂的是instrument类库，可以直接在类被装载到类加载器前，修改类；
 *  
 *  
 * 3.AOP 面向切面编程
 *      切面Aspect包含:
 *          切入点Pointcut: 插入拓展操作的时机；
 *          通知方法Advice: 具体的拓展操作；
 *          编织过程Weave:  目标方法与拓展操作拼接过程
 *      
 *      Spring框架两大核心：
 *          IOC 灵活装配对象
 *          AOP 动态拼接代码</pre>

#### 静态代理 （代理类聚合被代理类，在模拟目标方法，中实现功能拓展，存在类爆炸问题）

#### 动态代理 （动态体现在代理类是JVM自动生成的）
> collapsed=`true`,topicLinkUID=`174BDC57574A`


##### JDK动态代理
> collapsed=`true`


###### 1\.代理类聚合的是被代理类的接口，代理类与被代理类是兄弟关系；

###### 2\.需要手动注入被代理对象；

###### 3\.需要有接口

##### CGLib动态代理
> collapsed=`true`


###### 1\.代理类直接继承被代理类，因此被代理类不能是final类

###### 2\.无需创建被代理类对象，实质调用的就是代理类

###### 3\.不需要接口，但被代理类不能是final类

#### 面向切面编程 （AOP）
> collapsed=`true`

- NOTE
<pre>1.xml 声明式配置；
2.@Aspect 主机式配置</pre>

##### 切面 Aspect = Pointcut \+ Advice \+ Weave

##### 切入点 Pointcut \(拓展功能的时机\)

##### 通知方法 Advice （需要拓展的功能）

##### 编织过程 Weave （目标方法调用与通知方法调用融合的过程）

## 行为型

### 2\.ChainOfResponsibility 责任链模式\(Filter\)
> collapsed=`true`

- NOTE
<pre>责任链模式
1.对同一事件进行链式调用，调用过程分为前置、后置两部分；
2.中间任意一环中断，直接开始返回；
3.以FilterChain为例，前置处理对象为Resquest，后置处理对象为Response</pre>

#### Filter \(doFilter中传入Request、Response、Chain对象，实现栈式调用\)

#### FilterChain \(addFilter添加多个Filter\)

### 16\.Command 命令设计模式 （宏、事务、命令）
> collapsed=`true`

- NOTE
<pre> * 命令设计模式
 * 操作打包成命令，可以执行，也可以撤销；
 *
 * 1.命令的 do 和 undo 功能；
 * 2.与责任链模式搭配实现命令连续回退功能；
 * 3.与组合设计模式搭配实现宏 (树状结构，封装了一系列其他宏或命令)
 * 4.实现事务Translaction的提交和回滚功能</pre>

#### 场景1：普通可撤销命令 do\(\) 、undo\(\)，与责任链模式搭配可以实现连续撤销功能

#### 场景2：事务 commit\(\)、rollback\(\)

#### 场景3：与组合模式搭配，封装宏命令（一系列简单命令或其他宏的组合）

### 3\.Observer 观察者模式\(Callbacl、Listener、Observer、Hook\)
> collapsed=`true`

- NOTE
<pre>观察者模式：
1.拥有 被观察者(事件源)、观察者(事件监听器)、观察目标(事件)3种角色；
2.被观察者可以发出多种事件，并拥有处理不同时间的监听者，监听者收到被观察者发出的事件时，做出响应的响应；
3.观察者可以同时监听多个被观察者；
4.观察目标，自身具备getSource方法，方便观察者收到事件时，回溯到事件发起者，并做出关联反应。

类比：
1.观察者模式与责任链模式非常类似，适合针对某个事件执行流水线式处理；
2.不同在于责任链模式有前置和后置处理方法，并且中间任意一环崩溃，都可终止任务传递，观察者只有前置处理，且无法终止处理流程。
</pre>

#### 观察者\(event listener 同时监控多个被观察者\)

#### 被观察者\(event emitor 同时拥有多个观察者\)

#### 被观察目标\(event 可溯源\)

### 4\.Strategy 策略模式 \(fire\)
> collapsed=`true`

- NOTE
<pre>策略模式：
1.同类不同种操作，抽象公共接口，然后分别实现各自逻辑，函数入参面向接口，保证开闭原则;
2.操作(operate)与操作者(operator)解除耦合；</pre>

#### client\.fire\(Fireable\<T\> gun\)

#### interface Fireable\<T\>
> collapsed=`true`


##### class FireStrategy1 implement Fireable\<T\>

##### class FireStrategy2 implement Fireable\<T\>

##### \.\.\.\.\.

### 6\.Mediator 调停者设计模式（消息中间件）
> collapsed=`true`

- NOTE
<pre> * 调停者设计模式
 * 1.大的系统内部包含众多子模块，各子模块间都会相互交互，随着子模块不停拓展，还回陆续有新交互关系产生，这是系统会非常臃肿，可以抽出特定调停者角色，来管理两两之间关系；
 * 2.如果只涉及内部交互，调停者相当于管家角色，需要与外部交互式，想当与门面(Facd)角色；
 * 3.消息中间件是典型调停者涉及模式，消息生产者和消费者自身不直接发生关系，借助中间件实现解耦</pre>

#### Faced 系统涉及与外部交互时，交互逻辑交给门面实现

#### Mediator 只有系统内部模块交互时，交互逻辑交给调停者实现

### 11\.Iterator 迭代器设计模式 （容器、迭代器、泛型支持）
> collapsed=`true`

- NOTE
<pre> * 迭代器设计模式
 * 1.计算机存储数据的物理容器实质只有顺序存储(Array)和跳跃存储(LinkedList)两类，称为为物理存储，其余所有数据结构都称为逻辑结构；
 * 2.迭代器是集合容器的重要组成，在遍历元素时使用到；
 * 3.容器设计主要需要包含以下几点：
 *      实质存储结构 数组 or 链表
 *      记录存储元素个数遍历 size
 *      添加 add() 或 移除 remove() 元素的操作
 *      遍历元素的迭代器，可以直接实现Iterator接口，或使用内部类实现Iterator接口
 *
 * v1: 模拟顺序存储和跳跃存储
 * v2: 抽象公共Collection接口，保证Collection的引用，同时具备两种选择
 * v3: 实现Iterable迭代器协议
 * v4: 容器泛型支持</pre>

#### 存储
> collapsed=`true`


##### 物理存储
> collapsed=`true`


###### 顺序存储 ArrayList

###### 跳跃存储 LinkedList

##### 逻辑存储
> collapsed=`true`


###### 集合 Set

###### 哈希 Hash

###### 树 Tree

### 12\.Visitor 访问者模式 \(AST抽象语法树解析、针对不同采购商打折促销\)
> collapsed=`true`

- NOTE
<pre> * 访问者设计模式
 * 在被访问者结构不变情况下，传入不同访问者，从而动态实现对内部元素的访问动作。
 * 核心：被访问者结构固定，不承担访问动作，拓展变更的复杂性，转而有被访问者承担；
 *
 * 例如：某知名组装电器销售商，针对不同采购者，有不同优惠策略，而且策略经常会变化，但销售的商品组件固定。因此可以吧销售商看成被访问者，
 * 商品看成被访问者内部元素，不同采购商，看车不同访问者。不同优惠折扣绑定到不同采购商，商品原价保持不变。
 *
 * 三个决策
 *  被访问者
 *  被访问者内部元素
 *  访问者
 *
 * 注：访问者模式使用场景非常少，常出现在编译器AST（Abstract Sytanx Tree）抽象语法树生成过程中；
 * AST：叶子为数据，非叶子节点为预算符，节点层次越高，计算优先级越高</pre>

#### 角色
> collapsed=`true`


##### 被访问者
> collapsed=`true`


###### 内部元素 accept\(visitor\)

##### 访问者 visit\(part\)

#### ASM \(字节码处理类库\)
- NOTE
<pre> * ASM （Assembly Lanuage 作为汇编语言）字节码编辑类库使用
 * 官网指导手册：https://asm.ow2.io/asm4-guide.pdf
 *
 * java class file 包含内容
 * Magic：存放java类文件魔数(magic number 前4个字节) 和版本信息，java文件都是以 Oxcafebabe 开头，这样保证了Java虚拟机能很轻松分辨java字节码文件，和非java文件；
 * Version: 存放Java类版本信息， 具有重要意义，因为随着Java技术不断迭代，类文件格式也在不断变化，类文件的版本信息可以知道虚拟机如何去读取并处理类文件；
 * Constant Pool：存放类的文字字符串、类名、方法名、接口名，final 变量以及外部类的引用信息等常量，其在Java的动态链接中起到核心作用，平均大小占类文件60%左右；
 * Assess Flag：指定该文件中定义的是一个类、还是一个接口（一个class文件只能对应一个类或接口），同时指定了类或接口的访标记，如：public private abstract
 * This Class：指向类的全限定名称字符串常量的指针；
 * Super Class：指向类的父类的全限定名称字符串常量指针；
 * Interfaces：一个指针数组，存放给类或父类的所有实现接口的全限定名称的字符串常量指针。以上三项指向都是常量，特别是前两项，在使用ASM从已有类派生新类时，一般需要修改：
 *      已有类作为新类的父类，新类作为已有类的子类，同时还可以增加新接口实现；
 * Fields：对类或接口中声明的字段进行了细致描述。fields列表中仅列出本类或接口中的字段，不包括从超类和父类中直接继承的字段；
 * Methods：对类或接口中声明的方法进行细致描述。如：方法的名称、参数和返回值类型等，只包含本类或接口的方法，不包括从超类和父类继承的方法，使用ASM进行AOP编程，通常都是通过调整Method中的指令来实现的；
 * Class Attributes：存放了类或接口所定义属性的基本信息 （getter/setter）
 *</pre>
- TOPIC
<pre>174BDC57574A</pre>

### 18\.Memento 备忘录设计模式 \(快照、存盘、加载、对象序列化\\反序列化、transient\)
> collapsed=`true`

- NOTE
<pre> * 备忘录设计模式
 * 1.记录状态，方便场景重现，通常需要配合序列化使用；
 * 2.java自带序列化协议（ObjectInputStream，ObjectOutputStream）附带过多类型描述信息，使用google开源Protobuf进行序列化，更精简；
 * 3.凡是需要被序列化的对象都要集成Serializable类，不需要包含到序列化中的结构使用 transient修饰；
 * 4.复杂对象序列化方案有两种：
 *      方案1：序列化属性，save()顺序存盘，load()顺序读取，然后重新组装出复杂对象；
 *      方案2：直接让该复杂对象实现序列化解决，对整体进行存盘和度盘操作。
 *
 * 注：备忘录模式与命令逐级回撤不同，是一步到位的复原。
 * 常用在游戏开发场景</pre>

#### 序列化、反序列化
> collapsed=`true`


##### 方案1：java自带序列化 （Serializable、ObjectInputStream、ObjectOutputStream）

##### 方案2：第三方序列化框架（如:google的Protobuf），可以压缩空间

#### 快照方案
> collapsed=`true`


##### 整体快照（属性的存盘，加载顺序要一致）

##### 分部快照，然后重新组装 （属性各自实现序列化解决）

#### transient 修饰的属性 不会被序列化

### 19\.Template 模板设计模式 （流程控制方法在父类实现，流程细节保持抽象，放到子类拓展）
> collapsed=`true`

- NOTE
<pre> * 模板设计模式
 * 父类某方法封装了复杂调用流程（其他方法），只对子类暴露控制局部调用流程的方法，调用流程控制在父类手中，子类修改局部，产生差异化调用效果；
 * 凡是涉及钩子、监听器、回调的场景，实际让开发人员写的代码极少，真正调用钩子、回调、监听器的过程封装在父类中；</pre>

#### 父类控制调用流程

#### 子类实现具体流程

### 20\.State 状态设计模式 （动作随状态改变，FSM有限状态机）
> collapsed=`true`

- NOTE
<pre> * 状态设计模式
 * 根据状态决定行为
 * 实质：状态从对象中剥离，对象持有状态，并会修改状态，对对象发起的操作底层调用的是当前状态对应的操作，
 从而保持对象的结构稳定，状态的扩展性；</pre>

#### 线程调度状态改变

#### tcp连接状态改变

#### 状态机

### 21\.Intepreter 解析器设计模式 （动态脚本解析，基本不会用到）
- NOTE
<pre> * 解析器设计模式
 *
 * 动态脚本解析，用于解析脚本语言。基本不用</pre>
